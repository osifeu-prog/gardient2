from fastapi import APIRouter, HTTPException, Request
from pydantic import BaseModel
import httpx, os, re, time
import redis
from sqlalchemy import text
from bot.infrastructure import get_db_session  # assumes you have a session helper

router = APIRouter(prefix="/tx", tags=["tx-send"])

RPC = os.getenv("BSC_RPC", "https://bsc-dataseed.binance.org/")
REDIS_URL = os.getenv("REDIS_URL", "redis://127.0.0.1:6379/0")
rdb = redis.Redis.from_url(REDIS_URL, decode_responses=True)

# Allowlist: only these contract addresses can be used as tx.to
ALLOW_TO = set(a.lower() for a in os.getenv("TX_ALLOW_TO", "").split(",") if a.strip())
# Default allowlist includes SLH token if env not set
if not ALLOW_TO:
    ALLOW_TO.add("0xacb0a09414cea1c879c67bb7a877e4e19480f022")

MAX_RAW_LEN = int(os.getenv("TX_MAX_RAW_LEN", "30000"))  # chars
RATE_LIMIT_N = int(os.getenv("TX_RATE_LIMIT_N", "5"))
RATE_LIMIT_S = int(os.getenv("TX_RATE_LIMIT_S", "60"))

def _is_hex(s: str) -> bool:
    return bool(re.fullmatch(r"0x[0-9a-fA-F]+", s or ""))

async def _rpc(method: str, params, idv: int = 1):
    payload = {"jsonrpc":"2.0","method":method,"params":params,"id":idv}
    async with httpx.AsyncClient(timeout=30.0) as client:
        r = await client.post(RPC, json=payload)
        r.raise_for_status()
        j = r.json()
        if "error" in j:
            raise RuntimeError(j["error"].get("message","rpc error"))
        return j["result"]

class SendRawIn(BaseModel):
    raw_tx: str  # 0x...
    telegram_user_id: int | None = None
    note: str | None = None

def _ratelimit_key(ip: str) -> str:
    return f"rl:sendraw:{ip}"

def _check_rate_limit(ip: str):
    k = _ratelimit_key(ip)
    now = int(time.time())
    pipe = rdb.pipeline()
    pipe.incr(k)
    pipe.ttl(k)
    cnt, ttl = pipe.execute()
    if ttl == -1:
        rdb.expire(k, RATE_LIMIT_S)
    if int(cnt) > RATE_LIMIT_N:
        raise HTTPException(429, f"rate limit exceeded: {RATE_LIMIT_N}/{RATE_LIMIT_S}s")

@router.post("/sendRaw")
async def send_raw(req: Request, body: SendRawIn):
    ip = req.client.host if req.client else "unknown"
    _check_rate_limit(ip)

    if not _is_hex(body.raw_tx):
        raise HTTPException(400, "raw_tx must be 0x-hex")
    if len(body.raw_tx) > MAX_RAW_LEN:
        raise HTTPException(400, "raw_tx too large")

    # NOTE: extracting 'to' from raw tx reliably requires RLP decode.
    # For safety we enforce allowlist by requiring caller to pass to_addr in note or enforce at build stage.
    # Minimal: rely on build endpoint + policy; still log.
    try:
        txh = await _rpc("eth_sendRawTransaction", [body.raw_tx])
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

    # audit (best-effort)
    try:
        async with get_db_session() as s:
            await s.execute(
                text("INSERT INTO tx_audit (ip, telegram_user_id, tx_hash, to_addr, note) VALUES (:ip,:tuid,:txh,:to,:note)"),
                {"ip": ip, "tuid": body.telegram_user_id, "txh": txh, "to": None, "note": body.note},
            )
            await s.commit()
    except Exception:
        pass

    return {"ok": True, "tx_hash": txh}
