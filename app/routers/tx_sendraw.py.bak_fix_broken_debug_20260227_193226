from fastapi import APIRouter, HTTPException, Header, HTTPException
from pydantic import BaseModel
import httpx, os, re

router = APIRouter(prefix="/tx", tags=["tx-send"])

RPC = os.getenv("BSC_RPC", "https://bsc-dataseed.binance.org/")
ALLOW_TO = set(a.lower() for a in os.getenv("TX_ALLOW_TO", "").split(",") if a.strip())
if not ALLOW_TO:
    ALLOW_TO.add("0xacb0a09414cea1c879c67bb7a877e4e19480f022")

def _is_hexhash(s: str) -> bool:
    return bool(re.fullmatch(r"0x[0-9a-fA-F]{64}", s or ""))

async def _rpc(method: str, params, idv: int = 1):
    payload = {"jsonrpc":"2.0","method":method,"params":params,"id":idv}
    async with httpx.AsyncClient(timeout=30.0) as client:
        r = await client.post(RPC, json=payload)
        r.raise_for_status()
        j = r.json()
        if "error" in j:
            raise RuntimeError(j["error"].get("message","rpc error"))
        return j["result"]

class ReceiptIn(BaseModel):
    tx_hash: str

@router.post("/receipt")
async def receipt(body: ReceiptIn):
    txh = body.tx_hash
    if not _is_hexhash(txh):
        raise HTTPException(400, "tx_hash must be 0x + 64 hex chars")

    rcpt = await _rpc("eth_getTransactionReceipt", [txh])
    if rcpt is None:
        return {"ok": True, "found": False, "tx_hash": txh}

    to_addr = (rcpt.get("to") or "").lower()
    if to_addr and (to_addr not in ALLOW_TO):
        raise HTTPException(403, f"receipt to-address not allowed: {to_addr}")

    # Best-effort decode ERC20 Transfer event from logs
    transfers = []
    for lg in (rcpt.get("logs") or []):
        if (lg.get("address","").lower() != to_addr):
            continue
        topics = lg.get("topics") or []
        # Transfer(address,address,uint256) topic0
        if len(topics) >= 3 and (topics[0].lower() == "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"):
            frm = "0x" + topics[1][-40:]
            to  = "0x" + topics[2][-40:]
            data = lg.get("data","0x0")
            transfers.append({"from": frm, "to": to, "value_hex": data})

    return {
        "ok": True,
        "found": True,
        "status": rcpt.get("status"),
        "from": rcpt.get("from"),
        "to": rcpt.get("to"),
        "blockNumber": rcpt.get("blockNumber"),
        "gasUsed": rcpt.get("gasUsed"),
        "effectiveGasPrice": rcpt.get("effectiveGasPrice"),
        "transfers": transfers,
        "tx_hash": txh,
    }

def _env(name: str, default: str = "") -> str:
    import os
    return (os.getenv(name) or default).strip()

def _require_internal_key(x_guardian_key: str | None):
    expected = _env("GUARDIAN_INTERNAL_API_KEY", "")
    if not expected:
        # ×گ×‌ ×œ×گ ×”×•×’×“×¨ ×‍×¤×ھ×— ×‘×،×‘×™×‘×”, × ×—×،×•×‌ ×‘×›×•×•× ×” ×‘×¤×¨×•×“
        raise HTTPException(status_code=500, detail="GUARDIAN_INTERNAL_API_KEY not set")
    if not x_guardian_key or x_guardian_key.strip() != expected:
        raise HTTPException(status_code=401, detail="unauthorized")

def _token_allowlist() -> set[str]:
    raw = _env("GUARDIAN_TOKEN_ALLOWLIST", "")
    if not raw:
        return set()
    return set([x.strip().lower() for x in raw.split(",") if x.strip()])

def _enforce_to_allowlist(tx_to: str):
    allow = _token_allowlist()
    if not allow:
        raise HTTPException(status_code=500, detail="GUARDIAN_TOKEN_ALLOWLIST empty")
    if (tx_to or "").lower() not in allow:
        raise HTTPException(status_code=403, detail="tx.to not allowed")


class SendRawIn(BaseModel):
    rawTx: str
    raw_tx: str | None = None
    note: str | None = None

    def pick_raw(self) -> str:
        return self.rawTx or (self.raw_tx or "")

def _is_hex_tx(s: str) -> bool:
    return bool(re.fullmatch(r"0x[0-9a-fA-F]+", s or ""))

@router.post("/sendRaw")
async def send_raw_tx(body: SendRawIn, x_guardian_key: str | None = Header(default=None)):
    # Require internal key (SELHA -> Guardian)
    _require_internal_key(x_guardian_key)

    raw = (body.pick_raw() or "").strip()
    if not _is_hex_tx(raw) or len(raw) < 10:
        raise HTTPException(400, f"rawTx invalid: len={len(raw)} prefix={(raw[:2] if raw else ')!r}")

    # Broadcast
    txh = await _rpc("eth_sendRawTransaction", [raw])

    # Best effort: do NOT assume receipt here; client can call /tx/receipt later
    return {"ok": True, "tx_hash": txh}



