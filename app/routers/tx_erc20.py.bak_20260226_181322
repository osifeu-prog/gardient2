from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
import httpx, os, re

router = APIRouter(prefix="/tx/erc20", tags=["tx-erc20"])

RPC = os.getenv("BSC_RPC", "https://bsc-dataseed.binance.org/")
CHAIN_ID = 56

def _is_addr(a: str) -> bool:
    return bool(re.fullmatch(r"0x[a-fA-F0-9]{40}", a or ""))

def _addr32(a: str) -> str:
    return a.lower().replace("0x","").rjust(64, "0")

def _u256hex(x: int) -> str:
    if x < 0:
        raise ValueError("amount must be >= 0")
    return hex(x)[2:].rjust(64, "0")

async def _rpc(method: str, params, idv: int = 1):
    payload = {"jsonrpc":"2.0","method":method,"params":params,"id":idv}
    async with httpx.AsyncClient(timeout=15.0) as client:
        r = await client.post(RPC, json=payload)
        r.raise_for_status()
        j = r.json()
        if "error" in j:
            raise RuntimeError(j["error"].get("message","rpc error"))
        return j["result"]

async def _eth_call(to: str, data: str, from_addr: str | None = None):
    call_obj = {"to": to, "data": data}
    if from_addr:
        call_obj["from"] = from_addr
    return await _rpc("eth_call", [call_obj, "latest"])

async def _estimate_gas(to: str, data: str, from_addr: str | None = None):
    call_obj = {"to": to, "data": data}
    if from_addr:
        call_obj["from"] = from_addr
    res = await _rpc("eth_estimateGas", [call_obj])
    return int(res, 16)

class TransferBuildIn(BaseModel):
    token: str
    to: str
    amount_raw: int  # raw units (respect decimals)

class TransferBuildOut(BaseModel):
    chainId: int
    to: str
    data: str
    value: str
    gas_estimate: int

class TransferSimIn(BaseModel):
    token: str
    from_addr: str
    to: str
    amount_raw: int

@router.post("/transfer/build", response_model=TransferBuildOut)
async def build_transfer(body: TransferBuildIn):
    if not _is_addr(body.token): raise HTTPException(400, "invalid token address")
    if not _is_addr(body.to): raise HTTPException(400, "invalid recipient address")

    # transfer(address,uint256) selector = a9059cbb
    data = "0xa9059cbb" + _addr32(body.to) + _u256hex(int(body.amount_raw))

    try:
        gas = await _estimate_gas(body.token, data)
    except Exception:
        # If estimateGas fails, still return build payload (caller can simulate)
        gas = 0

    return TransferBuildOut(
        chainId=CHAIN_ID,
        to=body.token,
        data=data,
        value="0x0",
        gas_estimate=gas,
    )

@router.post("/transfer/simulate")
async def simulate_transfer(body: TransferSimIn):
    if not _is_addr(body.token): raise HTTPException(400, "invalid token address")
    if not _is_addr(body.from_addr): raise HTTPException(400, "invalid from address")
    if not _is_addr(body.to): raise HTTPException(400, "invalid recipient address")

    data = "0xa9059cbb" + _addr32(body.to) + _u256hex(int(body.amount_raw))

    try:
        res = await _eth_call(body.token, data, from_addr=body.from_addr)
        return {"ok": True, "eth_call_result": res}
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"reverted_or_failed: {e}")
