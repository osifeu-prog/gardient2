from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
import os, time, secrets
from typing import Any
from eth_account.messages import encode_defunct
from eth_account import Account

router = APIRouter(prefix="/auth/wallet", tags=["auth-wallet"])

CHALLENGE_TTL_S = 300  # 5 minutes
# in-memory store for now (good for local); for prod use Redis
_pending: dict[str, dict[str, Any]] = {}

class ChallengeIn(BaseModel):
    telegram_user_id: int | None = None
    purpose: str = "link_wallet"

class ChallengeOut(BaseModel):
    nonce: str
    message: str
    expires_in_s: int

class VerifyIn(BaseModel):
    nonce: str
    address: str
    signature: str
    telegram_user_id: int | None = None

@router.post("/challenge", response_model=ChallengeOut)
def challenge(body: ChallengeIn):
    nonce = secrets.token_urlsafe(24)
    now = int(time.time())
    exp = now + CHALLENGE_TTL_S
    app_name = os.getenv("APP_NAME", "Guardian")
    # EIP-191 style message
    msg = (
        f"{app_name} wallet link\n"
        f"purpose={body.purpose}\n"
        f"nonce={nonce}\n"
        f"ts={now}\n"
        f"expires={exp}\n"
    )
    _pending[nonce] = {"exp": exp, "purpose": body.purpose, "telegram_user_id": body.telegram_user_id, "message": msg}
    return ChallengeOut(nonce=nonce, message=msg, expires_in_s=CHALLENGE_TTL_S)

@router.post("/verify")
def verify(body: VerifyIn):
    rec = _pending.get(body.nonce)
    if not rec:
        raise HTTPException(status_code=400, detail="unknown nonce")
    if int(time.time()) > int(rec["exp"]):
        _pending.pop(body.nonce, None)
        raise HTTPException(status_code=400, detail="nonce expired")

    msg = encode_defunct(text=rec["message"])
    try:
        recovered = Account.recover_message(msg, signature=body.signature)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"bad signature: {e}")

    if recovered.lower() != body.address.lower():
        raise HTTPException(status_code=400, detail="signature does not match address")

    # success: return a minimal link object (DB persistence comes next)
    _pending.pop(body.nonce, None)
    return {"ok": True, "address": body.address, "telegram_user_id": body.telegram_user_id}
