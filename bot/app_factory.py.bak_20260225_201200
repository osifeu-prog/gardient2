import logging
import os
import time
import re
import html
from urllib.parse import quote
from typing import Callable, Awaitable

from telegram import Update, BotCommand
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes
from telegram.error import Conflict
from telegram.constants import ParseMode
from bot.config import BOT_TOKEN, ENV, ADMIN_CHAT_ID, WEBHOOK_URL, MODE, DONATE_URL
from bot.infrastructure import init_infrastructure, runtime_report
from bot.telemetry import log_json, exc_to_str, update_brief, log_event
from bot.rbac_store import has_role, grant_role, revoke_role, list_users_with_role
from bot.economy_store import (
    add_account,
    set_plan_price,
    list_plans,
    create_payment_request,
    list_pending_requests,
    get_request,
    set_request_status,
    add_points,
    get_points_balance,
    list_user_requests,
    upsert_referral,
    get_referrer,
)

START_TS = time.time()


def _uptime_s() -> int:
    return int(time.time() - START_TS)


def _git_sha() -> str:
    return (
        os.getenv("RAILWAY_GIT_COMMIT_SHA")
        or os.getenv("GIT_COMMIT_SHA")
        or os.getenv("COMMIT_SHA")
        or ""
    )


def is_admin(update: Update) -> bool:
    # legacy admin-chat gate
    return bool(ADMIN_CHAT_ID) and str(update.effective_chat.id) == str(ADMIN_CHAT_ID)


def is_owner(update: Update) -> bool:
    # owner is ADMIN_CHAT_ID (chat id)
    return bool(ADMIN_CHAT_ID) and str(update.effective_chat.id) == str(ADMIN_CHAT_ID)


async def is_admin_rbac(update: Update) -> bool:
    # owner always allowed; else admin role in DB
    if is_owner(update):
        return True
    try:
        return await has_role(int(update.effective_user.id), "admin")
    except Exception:
        # if DB not ready, fall back to legacy owner-only
        return False


ASCII_BANNER = ""
try:
    from pathlib import Path

    ASCII_BANNER = Path("assets/banner.txt").read_text(encoding="utf-8")
except Exception:
    ASCII_BANNER = (
        "=====================================\n"
        "==           SLH  GUARDIAN          ==\n"
        "=====================================\n"
    )


def _parse_amount(x: str) -> int | None:
    """
    Strict positive int parser.
    Returns None on invalid.
    """
    try:
        s = str(x).strip()
        if not re.fullmatch(r"\d+", s):
            return None
        v = int(s)
        if v <= 0:
            return None
        return v
    except Exception:
        return None


def _parse_request_id(raw: str) -> int | None:
    """
    Accepts: 123, #123
    Rejects: <id>, <request_id>, non-digits
    """
    if raw is None:
        return None
    s = str(raw).strip()
    if not s:
        return None
    if s.startswith("#"):
        s = s[1:].strip()
    if "<" in s or ">" in s:
        return None
    if not re.fullmatch(r"\d+", s):
        return None
    try:
        return int(s)
    except Exception:
        return None


def with_latency(name: str, fn: Callable[[Update, ContextTypes.DEFAULT_TYPE], Awaitable[None]]):
    async def _wrap(update: Update, context: ContextTypes.DEFAULT_TYPE):
        t0 = time.perf_counter()
        ok = True
        err = None
        try:
            await fn(update, context)
        except Exception as e:
            ok = False
            err = f"{type(e).__name__}: {e}"
            raise
        finally:
            dt_ms = int((time.perf_counter() - t0) * 1000)
            brief = update_brief(update)
            log_json(logging.INFO, "handler_latency", handler=name, ok=ok, dt_ms=dt_ms, **brief, error=err)

    return _wrap


def _public_menu_lines() -> list[str]:
    return [
        "Commands:",
        "/start",
        "/status",
        "/menu",
        "/whoami",
        "/health",
        "/donate",
        "/admins",
        "/ref",
        "/my",
        "/buy",
        "/claim",
        "/trade",
        "/prices",
        "/add_account",
    ]


def _admin_menu_lines() -> list[str]:
    return [
        "",
        "Admin:",
        "/admin",
        "/vars",
        "/webhook",
        "/diag",
        "/pingdb",
        "/pingredis",
        "/snapshot",
        "/pending",
        "/approve",
        "/reject",
        "/grant_admin",
        "/revoke_admin",
        "/dm",
        "/broadcast_admins",
        "/set_price",
    ]


async def start_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # start ref hook
    try:
        if context.args and len(context.args) >= 1 and str(context.args[0]).startswith("ref_"):
            ref_id = int(str(context.args[0]).split("_", 1)[1])
            u = update.effective_user
            if u:
                ok_link = await upsert_referral(ref_id, int(u.id))
                if ok_link:
                    log_event(logging.INFO, "referral_linked", referrer_id=ref_id, referred_id=int(u.id))
    except Exception:
        pass

    banner = (ASCII_BANNER or "").strip()
    public_lines = "\n".join(_public_menu_lines())
    admin_lines = "\n".join(_admin_menu_lines()) if is_admin(update) else ""

    plain = (
        (banner + "\n\n" if banner else "")
        + "SLH Guardian Security + Ops Control\n\n"
        + "Welcome to SLH Guardian.\n"
        + "Infra monitoring, ops control, and SaaS-ready foundation.\n\n"
        + public_lines
        + ("\n" + admin_lines if admin_lines else "")
        + "\n"
    )

    html_msg = ""
    if banner:
        html_msg += f"<pre>{html.escape(banner)}</pre>\n"
    html_msg += html.escape(
        "SLH Guardian Security + Ops Control\n\n"
        "Welcome to SLH Guardian.\n"
        "Infra monitoring, ops control, and SaaS-ready foundation.\n\n"
        + public_lines
        + ("\n" + admin_lines if admin_lines else "")
    )

    try:
        await update.message.reply_text(html_msg, parse_mode=ParseMode.HTML)
    except Exception:
        await update.message.reply_text(plain)

async def whoami_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    u = update.effective_user
    c = update.effective_chat
    lines = [
        "WHOAMI",
        f"user_id: {u.id if u else None}",
        f"username: @{u.username}" if u and u.username else "username: (none)",
        f"chat_id: {c.id if c else None}",
        f"chat_type: {c.type if c else None}",
        f"is_admin_chat: {is_admin(update)}",
    ]
    await update.message.reply_text("\n".join(lines))


async def menu_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    lines = _public_menu_lines()
    if is_admin(update):
        lines += _admin_menu_lines()
    await update.message.reply_text("\n".join(lines))


async def status_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(await runtime_report(full=is_admin(update)))


async def health_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    sha = _git_sha()
    lines = ["HEALTH", f"ENV: {ENV}", f"MODE: {MODE}", f"uptime_s: {_uptime_s()}"]
    if sha:
        lines.append(f"git_sha: {sha[:12]}")
    if is_admin(update):
        lines.append(f"webhook_url: {WEBHOOK_URL or 'MISSING'}")
    await update.message.reply_text("\n".join(lines))


async def ref_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    u = update.effective_user
    if not u:
        await update.message.reply_text("No user.")
        return
    bot_user = await context.bot.get_me()
    link = f"https://t.me/{bot_user.username}?start=ref_{u.id}"
    log_event(logging.INFO, "referral_link_issued", user_id=int(u.id), username=(u.username or None))
    await update.message.reply_text("REFERRAL LINK\n" + link)

    # QR (no extra deps)
    try:
        qr_url = f"https://api.qrserver.com/v1/create-qr-code/?size=240x240&data={quote(link)}"
        await context.bot.send_photo(chat_id=update.effective_chat.id, photo=qr_url, caption="QR (Referral)")
    except Exception:
        pass

async def my_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    u = update.effective_user
    if not u:
        await update.message.reply_text("No user.")
        return
    bal = await get_points_balance(int(u.id))
    reqs = await list_user_requests(int(u.id), limit=5)
    lines = [
        "MY",
        f"user_id: {u.id}",
        f"points: {bal}",
        "",
        "Recent requests:",
    ]
    if not reqs:
        lines.append("(none)")
    else:
        for r in reqs:
            lines.append(f"- #{r['id']} {r['kind']} {r['amount']} {r['currency']} [{r['status']}]")
    await update.message.reply_text("\n".join(lines))


async def buy_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    u = update.effective_user
    if not u:
        await update.message.reply_text("No user.")
        return
    if not context.args:
        await update.message.reply_text("Usage: /buy <amount> [note]")
        return
    amt = _parse_amount(context.args[0])
    if amt is None:
        await update.message.reply_text("Usage: /buy <amount> [note]\n(amount must be a positive integer)")
        return
    note = " ".join(context.args[1:]) if len(context.args) > 1 else None
    req_id = await create_payment_request(int(u.id), "buy_token", int(amt), "SELHA", note=note)
    log_event(
        logging.INFO,
        "economy_request_created",
        kind="buy_token",
        request_id=req_id,
        amount=int(amt),
        user_id=int(u.id),
        username=(u.username or None),
    )
    await update.message.reply_text(f"OK: buy request created #{req_id} (pending)")


async def claim_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    u = update.effective_user
    if not u:
        await update.message.reply_text("No user.")
        return
    if len(context.args) < 2:
        await update.message.reply_text("Usage: /claim <amount> <tx_ref> [note]")
        return
    amt = _parse_amount(context.args[0])
    if amt is None:
        await update.message.reply_text("Usage: /claim <amount> <tx_ref> [note]\n(amount must be a positive integer)")
        return
    tx = str(context.args[1]).strip()
    if not tx:
        await update.message.reply_text("Usage: /claim <amount> <tx_ref> [note]\n(tx_ref must be non-empty)")
        return
    note = " ".join(context.args[2:]) if len(context.args) > 2 else None
    req_id = await create_payment_request(int(u.id), "donate", int(amt), "SELHA", tx_ref=tx, note=note)
    log_event(
        logging.INFO,
        "economy_request_created",
        kind="donate",
        request_id=req_id,
        amount=int(amt),
        user_id=int(u.id),
        username=(u.username or None),
        tx_ref=tx,
    )
    await update.message.reply_text(f"OK: donation claim created #{req_id} (pending)")


async def pending_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await is_admin_rbac(update):
        await update.message.reply_text("Access denied.")
        return
    items = await list_pending_requests(limit=10)
    lines = ["PENDING REQUESTS:"]
    if not items:
        lines.append("(none)")
    else:
        for it in items:
            lines.append(
                f"- #{it['id']} user={it['user_id']} {it['kind']} {it['amount']} {it['currency']} tx={it['tx_ref'] or '-'}"
            )
    await update.message.reply_text("\n".join(lines))


async def approve_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await is_admin_rbac(update):
        await update.message.reply_text("Access denied.")
        return
    if not context.args:
        await update.message.reply_text("Usage: /approve <request_id>")
        return
    rid = _parse_request_id(context.args[0])
    if rid is None:
        await update.message.reply_text(
            "Usage: /approve <request_id>\n"
            "Example: /approve 1772037417160\n"
            "Tip: use /pending to list ids"
        )
        return

    req = await get_request(int(rid))
    if not req or req["status"] != "pending":
        await update.message.reply_text("Not found or not pending.")
        return

    await set_request_status(int(rid), "approved", decided_by=int(update.effective_user.id))
    await add_points(int(req["user_id"]), int(req["amount"]), reason=req["kind"], ref=str(rid))

    referrer = await get_referrer(int(req["user_id"]))
    if referrer:
        bonus = max(1, int(int(req["amount"]) * 0.05))
        await add_points(int(referrer), bonus, reason="ref_bonus", ref=str(rid))

    log_event(
        logging.INFO,
        "economy_request_decided",
        action="approve",
        request_id=int(rid),
        user_id=int(req["user_id"]),
        decided_by=int(update.effective_user.id),
        amount=int(req["amount"]),
        kind=req["kind"],
    )
    log_event(logging.INFO, "points_awarded", user_id=int(req["user_id"]), delta=int(req["amount"]), reason=req["kind"], ref=str(rid))
    await update.message.reply_text(f"OK: approved #{rid} and awarded {req['amount']} points")


async def reject_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await is_admin_rbac(update):
        await update.message.reply_text("Access denied.")
        return
    if not context.args:
        await update.message.reply_text("Usage: /reject <request_id>")
        return
    rid = _parse_request_id(context.args[0])
    if rid is None:
        await update.message.reply_text(
            "Usage: /reject <request_id>\n"
            "Example: /reject 1772037417160\n"
            "Tip: use /pending to list ids"
        )
        return

    req = await get_request(int(rid))
    if not req or req["status"] != "pending":
        await update.message.reply_text("Not found or not pending.")
        return

    await set_request_status(int(rid), "rejected", decided_by=int(update.effective_user.id))
    log_event(logging.INFO, "economy_request_decided", action="reject", request_id=int(rid), decided_by=int(update.effective_user.id))
    await update.message.reply_text(f"OK: rejected #{rid}")


async def add_account_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    u = update.effective_user
    if not u:
        await update.message.reply_text("No user.")
        return

    if not context.args:
        await update.message.reply_text(
            "Usage: /add_account <bank|crypto> <label> <details...>\n"
            "Example: /add_account crypto MyTON address=UQ...\n"
            "Example: /add_account bank MyBank bank=Hapoalim branch=123 account=456"
        )
        return

    acc_type = context.args[0].lower().strip()
    if acc_type not in ("bank", "crypto"):
        await update.message.reply_text("First arg must be bank or crypto.")
        return

    if len(context.args) < 2:
        await update.message.reply_text("Usage: /add_account <bank|crypto> <label> <details...>")
        return

    label = context.args[1]
    details: dict[str, str] = {}
    for token in context.args[2:]:
        if "=" in token:
            k, v = token.split("=", 1)
            details[k.strip()] = v.strip()
        else:
            details.setdefault("note", "")
            details["note"] = (details["note"] + " " + token).strip()

    acc_id = await add_account(int(u.id), acc_type, label, details)
    await update.message.reply_text(f"OK: account saved #{acc_id}")


async def prices_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    plans = await list_plans()
    lines = ["PRICES:"]
    if not plans:
        lines.append("(none)")
    else:
        for p in plans:
            lines.append(f"- {p['code']}: {p['price_amount']} {p['price_currency']} ({'active' if p['is_active'] else 'inactive'})")
    await update.message.reply_text("\n".join(lines))


async def set_price_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_owner(update):
        await update.message.reply_text("Access denied.")
        return
    if len(context.args) < 2:
        await update.message.reply_text("Usage: /set_price <plan_code> <amount>")
        return
    code = str(context.args[0]).strip()
    amt = _parse_amount(context.args[1])
    if amt is None:
        await update.message.reply_text("Usage: /set_price <plan_code> <amount>\n(amount must be a positive integer)")
        return
    await set_plan_price(code, int(amt), "SELHA")
    await update.message.reply_text(f"OK: price set {code} = {amt} SELHA")


async def trade_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    u = update.effective_user
    if not u:
        await update.message.reply_text("No user.")
        return
    if len(context.args) < 2:
        await update.message.reply_text(
            "Usage: /trade <buy|sell> <amount> [note]\n"
            "Example: /trade buy 100\n"
            "Example: /trade sell 50 reason=takeprofit"
        )
        return
    side = str(context.args[0]).lower().strip()
    if side not in ("buy", "sell"):
        await update.message.reply_text("First arg must be buy or sell.")
        return
    amt = _parse_amount(context.args[1])
    if amt is None:
        await update.message.reply_text("Usage: /trade <buy|sell> <amount> [note]\n(amount must be a positive integer)")
        return
    note = " ".join(context.args[2:]) if len(context.args) > 2 else None
    kind = "buy_token" if side == "buy" else "sell_token"
    req_id = await create_payment_request(int(u.id), kind, int(amt), "SELHA", note=note)
    await update.message.reply_text(f"OK: trade request created #{req_id} ({kind}) [pending]")


async def donate_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not DONATE_URL:
        await update.message.reply_text("Donations are not configured yet.")
        return
    await update.message.reply_text(f"DONATE / SUPPORT\n{DONATE_URL}")


async def vars_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update):
        await update.message.reply_text("Access denied.")
        return

    def mask(v):
        return "SET" if v else "MISSING"

    lines = [
        "VARS (SET/MISSING)",
        f"ENV: {ENV}",
        f"MODE: {MODE}",
        f"BOT_TOKEN: {mask(BOT_TOKEN)}",
        f"DATABASE_URL: {mask(os.getenv('DATABASE_URL'))}",
        f"REDIS_URL: {mask(os.getenv('REDIS_URL'))}",
        f"ADMIN_CHAT_ID: {mask(ADMIN_CHAT_ID)}",
        f"WEBHOOK_URL: {mask(WEBHOOK_URL)}",
        f"LOG_LEVEL: {mask(os.getenv('LOG_LEVEL'))}",
        f"OPENAI_API_KEY: {mask(os.getenv('OPENAI_API_KEY'))}",
    ]
    await update.message.reply_text("\n".join(lines))


async def webhookinfo_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update):
        await update.message.reply_text("Access denied.")
        return
    import httpx

    url = f"https://api.telegram.org/bot{BOT_TOKEN}/getWebhookInfo"
    async with httpx.AsyncClient(timeout=10.0) as client:
        r = await client.get(url)
    data = r.json().get("result", {})
    lines = [
        "WEBHOOK INFO",
        f"url: {data.get('url') or ''}",
        f"pending_update_count: {data.get('pending_update_count')}",
        f"last_error_date: {data.get('last_error_date')}",
        f"last_error_message: {data.get('last_error_message')}",
    ]
    await update.message.reply_text("\n".join(lines))


async def diag_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update):
        await update.message.reply_text("Access denied.")
        return
    sha = _git_sha()
    await update.message.reply_text(
        "\n".join(
            [
                "DIAG",
                f"env: {ENV}",
                f"mode: {MODE}",
                f"uptime_s: {_uptime_s()}",
                f"git_sha: {(sha[:12] if sha else '(none)')}",
                f"webhook_url: {WEBHOOK_URL or 'MISSING'}",
            ]
        )
    )


async def pingdb_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update):
        await update.message.reply_text("Access denied.")
        return
    t0 = time.perf_counter()
    ok = True
    err = None
    try:
        _ = await runtime_report(full=False)
    except Exception as e:
        ok = False
        err = f"{type(e).__name__}: {e}"
    dt = int((time.perf_counter() - t0) * 1000)
    await update.message.reply_text(f"DB ping: {'OK' if ok else 'FAIL'} ({dt} ms){'' if not err else ' | ' + err}")


async def pingredis_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update):
        await update.message.reply_text("Access denied.")
        return
    t0 = time.perf_counter()
    ok = True
    err = None
    try:
        _ = await runtime_report(full=False)
    except Exception as e:
        ok = False
        err = f"{type(e).__name__}: {e}"
    dt = int((time.perf_counter() - t0) * 1000)
    await update.message.reply_text(f"Redis ping: {'OK' if ok else 'FAIL'} ({dt} ms){'' if not err else ' | ' + err}")


async def snapshot_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update):
        await update.message.reply_text("Access denied.")
        return

    import httpx

    base = "https://gardient2-production.up.railway.app"
    try:
        async with httpx.AsyncClient(timeout=10.0) as client:
            version = (await client.get(f"{base}/version")).text.strip()
            healthz = (await client.get(f"{base}/healthz")).text.strip()
            readyz = (await client.get(f"{base}/readyz")).text.strip()
            snap = (await client.get(f"{base}/snapshot")).text.strip()

        msg = "\n".join(
            [
                "SNAPSHOT",
                f"base: {base}",
                "",
                f"/version: {version}",
                f"/healthz: {healthz}",
                f"/readyz:  {readyz}",
                f"/snapshot: {snap}",
            ]
        )
        await update.message.reply_text(msg)
    except Exception as e:
        await update.message.reply_text(f"snapshot error: {type(e).__name__}: {e}")


async def smoke_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Admin-only smoke (runs HTTP checks against current BASE)
    if not is_admin(update):
        await update.message.reply_text("Access denied.")
        return

    import httpx

    base = os.getenv("PUBLIC_BASE_URL") or "https://gardient2-production.up.railway.app"
    lines = ["SMOKE", f"base: {base}"]
    try:
        async with httpx.AsyncClient(timeout=10.0) as client:
            v = (await client.get(f"{base}/version")).text.strip()
            h = (await client.get(f"{base}/healthz")).text.strip()
            r = (await client.get(f"{base}/readyz")).text.strip()
            m = (await client.get(f"{base}/metrics")).text
        lines += ["", "/version:", v, "", "/healthz:", h, "", "/readyz:", r, ""]
        # keep metrics short
        wanted = []
        for line in m.splitlines():
            if "bot_error" in line or "bot_commands_total" in line or "http_requests_total" in line:
                wanted.append(line)
        lines.append("metrics (filtered):")
        lines += wanted[:80] if wanted else ["(no matches)"]
    except Exception as e:
        lines.append(f"ERROR: {type(e).__name__}: {e}")

    text = "\n".join(lines)
    # Telegram message limit: keep safe
    if len(text) > 3500:
        text = text[:3500] + "\n...\n(truncated)"
    await update.message.reply_text(text)

async def admin_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_admin(update):
        await update.message.reply_text("Access denied.")
        return
    await update.message.reply_text("BOOT/ADMIN REPORT\n\n" + await runtime_report(full=True))


async def grant_admin_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_owner(update):
        await update.message.reply_text("Access denied.")
        return
    if not context.args:
        await update.message.reply_text("Usage: /grant_admin <user_id>")
        return
    rid = _parse_request_id(context.args[0])
    if rid is None:
        await update.message.reply_text("Usage: /grant_admin <user_id>")
        return
    await grant_role(int(rid), "admin", granted_by=int(update.effective_user.id))
    await update.message.reply_text(f"OK: granted admin to {rid}")


async def revoke_admin_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_owner(update):
        await update.message.reply_text("Access denied.")
        return
    if not context.args:
        await update.message.reply_text("Usage: /revoke_admin <user_id>")
        return
    rid = _parse_request_id(context.args[0])
    if rid is None:
        await update.message.reply_text("Usage: /revoke_admin <user_id>")
        return
    await revoke_role(int(rid), "admin")
    await update.message.reply_text(f"OK: revoked admin from {rid}")


async def admins_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await is_admin_rbac(update):
        await update.message.reply_text("Access denied.")
        return
    admins = await list_users_with_role("admin")
    lines = ["ADMINS:"]
    if not admins:
        lines.append("(none)")
    else:
        for a in admins:
            lines.append(f"- {a['user_id']} (by {a['granted_by']} at {a['granted_at']})")
    await update.message.reply_text("\n".join(lines))


async def dm_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await is_admin_rbac(update):
        await update.message.reply_text("Access denied.")
        return
    if len(context.args) < 2:
        await update.message.reply_text("Usage: /dm <user_id> <msg>")
        return
    uid = _parse_request_id(context.args[0])
    if uid is None:
        await update.message.reply_text("Usage: /dm <user_id> <msg>")
        return
    msg = " ".join(context.args[1:])
    await context.bot.send_message(chat_id=int(uid), text=msg)
    await update.message.reply_text("OK: sent.")


async def broadcast_admins_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_owner(update):
        await update.message.reply_text("Access denied.")
        return
    if not context.args:
        await update.message.reply_text("Usage: /broadcast_admins <msg>")
        return
    msg = " ".join(context.args)
    admins = await list_users_with_role("admin")
    sent = 0
    for a in admins:
        try:
            await context.bot.send_message(chat_id=int(a["user_id"]), text=msg)
            sent += 1
        except Exception:
            pass
    await update.message.reply_text(f"OK: broadcasted to {sent} admins.")


async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE):
    e = context.error
    brief = update_brief(update) if isinstance(update, Update) else {}
    log_json(logging.ERROR, "bot_error", error_type=type(e).__name__, error=str(e), trace=exc_to_str(e), **brief)
    if isinstance(e, Conflict):
        log_json(logging.ERROR, "bot_conflict_409", **brief)


async def post_init(app):
    await init_infrastructure()
    if ADMIN_CHAT_ID:
        await app.bot.send_message(chat_id=int(ADMIN_CHAT_ID), text="BOOT/ADMIN REPORT\n\n" + await runtime_report(full=True))

    # Telegram official commands (autocomplete)
    try:
        await app.bot.set_my_commands(
            [
                BotCommand("start", "Start"),
                BotCommand("menu", "Show menu"),
                BotCommand("status", "Infra status"),
                BotCommand("health", "Health report"),
                BotCommand("whoami", "User info"),
                BotCommand("donate", "Support / donate"),
                BotCommand("admins", "List admins"),
                BotCommand("ref", "Referral link"),
                BotCommand("my", "My points & requests"),
                BotCommand("buy", "Buy request"),
                BotCommand("claim", "Claim donation"),
                BotCommand("trade", "Trade request"),
                BotCommand("prices", "List prices"),
                BotCommand("add_account", "Add payout account"),
                BotCommand("pending", "List pending (admin)"),
                BotCommand("approve", "Approve request (admin)"),
                BotCommand("reject", "Reject request (admin)"),
                BotCommand("grant_admin", "(owner) Grant admin"),
                BotCommand("revoke_admin", "(owner) Revoke admin"),
                BotCommand("dm", "DM a user (admin)"),
                BotCommand("broadcast_admins", "(owner) Broadcast to admins"),
                BotCommand("set_price", "(owner) Set plan price"),
            ]
        )
    except Exception:
        pass


def build_application():
    if not BOT_TOKEN:
        raise ValueError("BOT_TOKEN not set")
    app = ApplicationBuilder().token(BOT_TOKEN).post_init(post_init).build()
    app.add_error_handler(error_handler)

    # Core
    app.add_handler(CommandHandler("start", with_latency("start", start_cmd)))
    app.add_handler(CommandHandler("menu", with_latency("menu", menu_cmd)))
    app.add_handler(CommandHandler("status", with_latency("status", status_cmd)))
    app.add_handler(CommandHandler("health", with_latency("health", health_cmd)))
    app.add_handler(CommandHandler("whoami", with_latency("whoami", whoami_cmd)))
    app.add_handler(CommandHandler("donate", with_latency("donate", donate_cmd)))

    # Admin
    app.add_handler(CommandHandler("vars", with_latency("vars", vars_cmd)))
    app.add_handler(CommandHandler("webhook", with_latency("webhook", webhookinfo_cmd)))
    app.add_handler(CommandHandler("diag", with_latency("diag", diag_cmd)))
    app.add_handler(CommandHandler("pingdb", with_latency("pingdb", pingdb_cmd)))
    app.add_handler(CommandHandler("pingredis", with_latency("pingredis", pingredis_cmd)))
    app.add_handler(CommandHandler("snapshot", with_latency("snapshot", snapshot_cmd)))
    app.add_handler(CommandHandler("smoke", with_latency("smoke", smoke_cmd)))
    app.add_handler(CommandHandler("admin", with_latency("admin", admin_cmd)))
    app.add_handler(CommandHandler("grant_admin", with_latency("grant_admin", grant_admin_cmd)))
    app.add_handler(CommandHandler("revoke_admin", with_latency("revoke_admin", revoke_admin_cmd)))
    app.add_handler(CommandHandler("admins", with_latency("admins", admins_cmd)))
    app.add_handler(CommandHandler("dm", with_latency("dm", dm_cmd)))
    app.add_handler(CommandHandler("broadcast_admins", with_latency("broadcast_admins", broadcast_admins_cmd)))

    # Economy
    app.add_handler(CommandHandler("ref", with_latency("ref", ref_cmd)))
    app.add_handler(CommandHandler("my", with_latency("my", my_cmd)))
    app.add_handler(CommandHandler("buy", with_latency("buy", buy_cmd)))
    app.add_handler(CommandHandler("claim", with_latency("claim", claim_cmd)))
    app.add_handler(CommandHandler("trade", with_latency("trade", trade_cmd)))
    app.add_handler(CommandHandler("prices", with_latency("prices", prices_cmd)))
    app.add_handler(CommandHandler("add_account", with_latency("add_account", add_account_cmd)))
    app.add_handler(CommandHandler("pending", with_latency("pending", pending_cmd)))
    app.add_handler(CommandHandler("approve", with_latency("approve", approve_cmd)))
    app.add_handler(CommandHandler("reject", with_latency("reject", reject_cmd)))
    app.add_handler(CommandHandler("set_price", with_latency("set_price", set_price_cmd)))

    return app