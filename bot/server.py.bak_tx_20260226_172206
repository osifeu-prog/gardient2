import logging
import os
import time
from contextlib import asynccontextmanager

from fastapi import FastAPI, Request, Response
from app.routers.wallet_auth import router as wallet_auth_router
from app.routers.bsc_chain import router as bsc_router
from fastapi.responses import JSONResponse
from prometheus_client import Counter, Histogram, CollectorRegistry, generate_latest, CONTENT_TYPE_LATEST
from telegram import Update

from bot.app_factory import build_application
from bot.infrastructure import init_infrastructure, run_migrations_safe
from bot.telemetry import log_json, exc_to_str

APP_START = time.time()

REGISTRY = CollectorRegistry()

REQS = Counter(
    "http_requests_total",
    "HTTP requests total",
    ["path", "method", "status"],
    registry=REGISTRY,
)
LAT = Histogram(
    "http_request_latency_ms",
    "HTTP request latency ms",
    ["path", "method"],
    buckets=(5, 10, 25, 50, 100, 250, 500, 1000, 2000, 5000),
    registry=REGISTRY,
)


BOT_CMDS = Counter(
    "bot_commands_total",
    "Bot commands total",
    ["cmd"],
    registry=REGISTRY,
)
ptb_app = None
def uptime_s() -> int:
    return int(time.time() - APP_START)

def git_sha() -> str:
    return (
        os.getenv("RAILWAY_GIT_COMMIT_SHA")
        or os.getenv("GIT_COMMIT_SHA")
        or os.getenv("COMMIT_SHA")
        or ""
    )

@asynccontextmanager
async def lifespan(_app: FastAPI):
    # Infra first
    await init_infrastructure()

    # lazy-init: build PTB only if BOT_TOKEN exists
    global ptb_app
    import os, logging
    if ptb_app is None:
        if os.getenv("BOT_TOKEN"):
            ptb_app = build_application()
            logging.getLogger(__name__).info("PTB application initialized (lazy)")
        else:
            logging.getLogger(__name__).info("BOT_TOKEN not set; PTB stays disabled")
    await run_migrations_safe()
    # Telegram bot init/start
    await ptb_app.initialize()
    await ptb_app.start()
    log_json(
        logging.INFO,
        "fastapi_startup",
        uptime_s=uptime_s(),
        git_sha=(git_sha()[:12] if git_sha() else None),
    )
    try:
        yield
    finally:
        await ptb_app.stop()
        await ptb_app.shutdown()
        log_json(logging.INFO, "fastapi_shutdown")

app = FastAPI(lifespan=lifespan)

app.include_router(bsc_router)
app.include_router(wallet_auth_router)
@app.middleware("http")
async def _mw(request: Request, call_next):
    t0 = time.perf_counter()
    path = request.url.path
    method = request.method
    status = 500
    try:
        resp = await call_next(request)
        status = resp.status_code
        return resp
    except Exception as e:
        log_json(
            logging.ERROR,
            "http_error",
            path=path,
            method=method,
            error_type=type(e).__name__,
            error=str(e),
            trace=exc_to_str(e),
        )
        return JSONResponse({"ok": False, "error": type(e).__name__}, status_code=500)
    finally:
        dt_ms = int((time.perf_counter() - t0) * 1000)
        LAT.labels(path=path, method=method).observe(dt_ms)
        REQS.labels(path=path, method=method, status=str(status)).inc()
        log_json(logging.INFO, "http_access", path=path, method=method, status=status, dt_ms=dt_ms)

@app.get("/healthz")
async def healthz():
    return {"ok": True, "uptime_s": uptime_s(), "git_sha": (git_sha()[:12] if git_sha() else None)}

@app.get("/version")
async def version():
    return {"service": "gardient2", "git_sha": git_sha(), "uptime_s": uptime_s()}

@app.get("/readyz")
async def readyz():
    t0 = time.perf_counter()
    try:
        from bot.infrastructure import runtime_report
        _ = await runtime_report(full=False)
        return {"ok": True, "elapsed_ms": int((time.perf_counter() - t0) * 1000)}
    except Exception as e:
        return JSONResponse(
            {"ok": False, "elapsed_ms": int((time.perf_counter() - t0) * 1000), "error": f"{type(e).__name__}: {e}"},
            status_code=503,
        )

    try:
        from bot.infrastructure import check_postgres, check_redis
        tdb = time.perf_counter()
        await check_postgres()
        payload["db_ms"] = int((time.perf_counter() - tdb) * 1000)
        payload["db_ok"] = True
    except Exception as e:
        payload["db_ok"] = False
        payload["db_error"] = f"{type(e).__name__}: {e}"
        payload["ok"] = False

    try:
        tred = time.perf_counter()
        await check_redis()
        payload["redis_ms"] = int((time.perf_counter() - tred) * 1000)
        payload["redis_ok"] = True
    except Exception as e:
        payload["redis_ok"] = False
        payload["redis_error"] = f"{type(e).__name__}: {e}"
        payload["ok"] = False

    payload["elapsed_ms"] = int((time.perf_counter() - t0) * 1000)

    if payload["ok"]:
        return payload
    return JSONResponse(payload, status_code=503)


@app.get("/snapshot")
async def snapshot():
    import datetime
    v = await version()
    h = await healthz()
    r = await readyz()
    return {
        "ok": True,
        "ts_utc": datetime.datetime.now(datetime.UTC).isoformat(),
        "service": v.get("service"),
        "git_sha": v.get("git_sha"),
        "uptime_s": v.get("uptime_s"),
        "healthz": h,
        "readyz": r,
        "webhook": "/tg/webhook",
    }

@app.get("/metrics")
async def metrics():
    return Response(generate_latest(REGISTRY), media_type=CONTENT_TYPE_LATEST)

@app.post("/tg/webhook")
async def tg_webhook(request: Request):
    payload = await request.json()
    # Count /commands from Telegram updates (best-effort)
    try:
        msg = payload.get("message") or payload.get("edited_message") or {}
        text = (msg.get("text") or "").strip()
        if text.startswith("/"):
            cmd = text.split()[0].split("@")[0].lstrip("/")
            if cmd:
                BOT_CMDS.labels(cmd=cmd).inc()
    except Exception:
        pass

    update = Update.de_json(payload, ptb_app.bot)
    await ptb_app.process_update(update)
    return {"ok": True}



